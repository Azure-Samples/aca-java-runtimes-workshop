[[welcome]]
= Welcome
Let's start from the beginning.
Quarkus.
What's Quarkus?
That's a pretty good question and probably a good start.
If you go to the https://quarkus.io[Quarkus web site], you'll read that Quarkus is "_A Kubernetes Native Java stack tailored for OpenJDK HotSpot & GraalVM, crafted from the best of breed Java libraries and standards_."
This description is somewhat unclear but does an outstanding job at using bankable keywords.
It's also written: "_Supersonic Subatomic Java_."
Still very foggy.
In practice, Quarkus is a stack to develop distributed systems and modern applications in Java, Kotlin, or Scala.
Quarkus applications are tailored for the Cloud, containers, and Kubernetes.
That does not mean you can't use Quarkus in other environments, there are no limits, but the principles infused in Quarkus have made containerization of applications more efficient.
In this workshop, we will explain what Quarkus is and because the best way to understand Quarkus is to use it, build a set of microservices with it.
Again, Quarkus is not limited to microservices, but it's a generally well-understood type of architecture.

This workshop offers attendees an intro-level, hands-on session with Quarkus, from the first line of code to making services, to consuming them, and finally to assembling everything in a consistent system.
But, what are we going to build?
Well, it's going to be a set of microservices:

* Using Quarkus
* Using HTTP and events (with Apache Kafka)
* With some parts of the dark side of microservices (resilience, health, monitoring with Prometheus)
* Answer the ultimate question: are super-heroes stronger than super-villains?

This workshop is a BYOL (_Bring Your Own Laptop_) session, so bring your Windows, OSX, or Linux laptop.
You need JDK {jdk-version} on your machine, Apache Maven ({maven-version}), and Docker.
On Mac and Windows, Docker for _x_ is recommended instead of the Docker toolbox setup.

What you are going to learn:

* What is Quarkus, and how you can use it
* How to build an HTTP endpoint (REST API) with Quarkus
* How to access a relational database
* How you can use Swagger and OpenAPI
* How you test your microservice
* How to build a reactive microservice, including reactive data access
* How you improve the resilience of your service
* How to build event-driven microservices with Kafka
* How to build native executable
* How to extend Quarkus with extensions
* And much more!

Ready? Here we go!

== Presenting the Workshop

=== What Is This Workshop About?

=== What Will You Be Developing?

[plantuml,align=center,format=png]
----
include::{plantDir}/welcome-physical-architecture.puml[]
----

=== What Will You Be Deploying?

=== How Does This Workshop Work?

You have this material in your hands, and you can now follow it step by step. The structure of this workshop is as follow :

1. _Installing all the needed tools_: in this section, you will install all the tools and code to be able to bundle, package and deploy our application.

2. _Setup Azure resources_: this section introduces Azure and the Container Apps service to prepare all the needed resources for our application. You will create an entire infrastructure on Azure (Container Registry, Postgres databases, etc.) to make everything ready for deployment.

3. _Running the Application Locally_: in this section, you will build Docker images out of our microservices, execute them locally with Docker compose, push them to Azure Registry, all that using Docker and Azure CLI.

4. _Setup CI/CD and deploy application_: in this section, you will setup a CI/CD pipeline using GitHub Actions so that our application builds and deploy automatically on new commits.

5. _Administrating_: in this section, you will add some load to your microservices, monitor them, scale them, check the logs, etc.

=== What Do You Have to Do?

This workshop should be as self-explanatory as possible. So your job is to follow the instructions by yourself, do what you are supposed to do, and do not hesitate to ask for any clarification or assistance; that's why the team is here.

Oh, and be ready to have some fun!

=== Pre-requisites

[cols="1,1"]
|===
| Java                | {jdk-version} https://docs.microsoft.com/java/openjdk/download?WT.mc_id=javascript-0000-yolasors[Get OpenJDK]
| Maven               | {maven-version} https://maven.apache.org/download.cgi[Get Maven]
| Docker              | {docker-version} https://docs.docker.com/get-docker/[Get Docker]
| Azure CLI           | https://learn.microsoft.com/cli/azure/install-azure-cli?WT.mc_id=javascript-0000-yolasors#install[Get Azure CLI]
| Git                 | https://git-scm.com
| GitHub account      | https://github.com/join
| Azure account       | https://azure.microsoft.com/free/?WT.mc_id=javascript-0000-yolasors[https://azure.microsoft.com/free]

If you're attending this workshop at Devoxx BE, you can use this link to redeem an Azure Pass: https://azcheck.in/dbe221010.
Once you have your code, copy it and click on the button *Get on board with Azure*, then follow the instructions.

| A code editor, such as VS Code, Eclipse, or IntelliJ | https://code.visualstudio.com/Download?WT.mc_id=javascript-0000-yolasors[Get VS Code]

|===

If you have VS Code and Docker installed on your machine, the quickest way to set up your environment is to use the pre-configured https://code.visualstudio.com/docs/remote/containers?WT.mc_id=javascript-0000-yolasors[dev container] of the template project. Install the https://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.vscode-remote-extensionpack&WT.mc_id=javascript-0000-yolasors[Remote Development extension] in VS Code, and skip to the next section.

TIP: You can learn more about dev containers in https://docs.microsoft.com/shows/beginners-series-to-dev-containers/?WT.mc_id=javascript-0000-yolasors[this video series].

You can test your installation by running the following commands:

[source,shell]
----
java -version
mvn --version
docker --version
az --version
----

=== Setting Up the Project

Open https://github.com/Azure/aca-java-runtimes-workshop[this GitHub repository] and click on `Use this template`. 

image::../images/github-template.png[Screenshot of GitHub showing the "Use this template" button]

You will be redirected to the repository creation page. Enter a name for your new repository, set the repo visibility to `public` and click on `Create repository from template`.

Once the repository is created, clone it locally using git.

1. Select the **Code** button, then copy your repository url.
+
image::../images/github-clone.png[Screenshot of GitHub showing the repository URL]

2. Open a terminal and run:
+
[source,shell]
----
git clone <your_repo_url>
----

If you chose to use the dev container environment, open the project in VS Code, click on the green button in the bottom left corner of the window and select *Reopen in Container*. The first time it will take some time to download and setup the container image, meanwhile you can go ahead and read the next sections.

=== Azure and Cloud Services

Azure is Microsoft's cloud platform. It provides a wide range of services, from compute to storage, from databases to AI, from IoT to containers, from networking to security, and much more.

For this workshop, we'll use in particular the following services:

- Azure Container Apps: a managed container service to run our microservices.
- Azure Container Registry: a private container registry to store our Docker images.
- Azure Database for PostgreSQL: a managed PostgreSQL database.

==== What's Azure Container Apps?

https://azure.microsoft.com/products/container-apps/?WT.mc_id=javascript-0000-yolasors[Azure Container Apps] is a fully managed serverless container service on Azure. It allows you to run containerized applications without worrying about orchestration or managing complex infrastructure such as Kubernetes. You write code using your preferred programming language or framework (in this workshop it's Java and Quarkus, but it can be anything), and build microservices with full support for Distributed Application Runtime (https://dapr.io/[Dapr]). Then, your containers will scale dynamically based on HTTP traffic or events powered by Kubernetes Event-Driven Autoscaling (https://keda.sh[KEDA]).

There are already a few compute resources on Azure: from IAAS to FAAS. Azure Container Apps sits between PAAS and FAAS. On one hand, it feels more PaaS, because you are not forced into a specific programming model and you can control the rules on which to scale out / scale in. On the other hand, it has quite some serverless characteristics like scaling to zero, event-driven scaling, per second pricing and the ability to leverage Dapr's event-based bindings.

image::../images/azure-compute-services.png[Diagram showing the different compute resources on Azure]

Container Apps is built on top of Azure Kubernetes Service, including a deep integration with KEDA (event-driven auto scaling for Kubernetes), Dapr (distributed application runtime) and Envoy (a service proxy designed for cloud-native applications). The underlying complexity is completely abstracted for the end-user. So no need to configure your K8S service, deployment, ingress, volume manifestsâ€¦ You get a very simple API and user interface to configure the desired configuration for your containerized application. This simplification means also less control, hence the difference with AKS.

image::../images/azure-container-apps.png[Diagram showing the architecture of Azure Container Apps]

Azure Container Apps has the following features:

- _Revisions_: automatic versioning that helps to manage the application lifecycle of your container apps
- _Traffic control_: split incoming HTTP traffic across multiple revisions for Blue/Green deployments and A/B testing
- _Ingress_: simple HTTPS ingress configuration, without the need to worry about DNS and certificates
- _Autoscaling_: leverage all KEDA-supported scale triggers to scale your app based on external metrics
- _Secrets_: deploy secrets that are securely shared between containers, scale rules and Dapr sidecars
- _Monitoring_: the standard output and error streams are automatically written to Log Analytics
- _Dapr_: through a simple flag, you can enable native Dapr integration for your Container Apps

Azure Container Apps introduces the following concepts:

- _Environment_: this is a secure boundary around a group of Container Apps. They are deployed in the same virtual network, these apps can easily intercommunicate easily with each other and they write logs to the same Log Analytics workspace. An environment can be compared with a Kubernetes namespace.

- _Container App_: this is a group of containers (pod) that is deployed and scale together. They share the same disk space and network.

- _Revision_: this is an immutable snapshot of a Container App. New revisions are automatically created and are valuable for HTTP traffic redirection strategies, such as A/B testing.

image::../images/aca-environment.png[Diagram showing the environment concept in Azure Container Apps]

=== Setting Up Azure

To be able to deploy the application to Azure, you first need an Azure subscription. If you don't have one, go to https://azure.microsoft.com/free/?WT.mc_id=javascript-0000-yolasors[https://azure.microsoft.com/free] and register.

[NOTE]
====
If you're attending this workshop at Devoxx BE, you can use this link to redeem an Azure Pass: https://azcheck.in/dbe221010.
Once you have your code, copy it and click on the button *Get on board with Azure*, then follow the instructions.
====

Once you have created your Azure subscription, we'll spend some time to create all the resources needed to deploy our Apps. We'll do that mostly using the Azure CLI, but at any point you can go to https://portal.azure.com?WT.mc_id=javascript-0000-yolasors[Azure Portal] to have a visual look at the resources we'll be configuring.

First, sign in to your Azure account using the Azure CLI:

[source,shell]
----
az login
----

Make sure you are using the right subscription with:

[source,shell]
----
az account show
----

Now we'll configure the CLI to automatically install extensions when needed. The Azure CLI is extensible, some commands are part of the core, but others are provided by extensions, such as the `az containerapp` command we'll be using later.

[source,shell]
----
az config set extension.use_dynamic_install=yes_without_prompt
----

=== Creating the Azure Resources

We'll create the infrastructure for our application so we can later deploying the microservices to Azure Container Apps.

==== Setting Up the Azure Environment Variables

Let's first set a few environment variables that will help us in creating the Azure infrastructure.

[source,shell]
----
RESOURCE_GROUP="rg-java-runtimes"
LOCATION="eastus2"
TAG="java-runtimes"
LOG_ANALYTICS_WORKSPACE="logs-java-runtimes"
UNIQUE_IDENTIFIER=$(whoami)
REGISTRY="javaruntimesregistry"$UNIQUE_IDENTIFIER
IMAGES_TAG="1.0"
----

Now let's create the Azure resources.

===== Resource Group

A https://learn.microsoft.com/azure/azure-resource-manager/management/manage-resource-groups-portal?WT.mc_id=javascript-0000-yolasors[resource group] is a container that holds related resources for an Azure solution. The resource group can include all the resources for the solution, or only those resources that you want to manage as a group. In our workshop, all the databases, all the microservices, etc. will be grouped into a single resource group.

Run the following command to create the Java Runtimes resource group:

[source,shell]
----
az group create \
  --name "$RESOURCE_GROUP" \
  --location "$LOCATION" \
  --tag system="$TAG"
----

===== Log Analytics Workspace

https://learn.microsoft.com/azure/azure-monitor/logs/quick-create-workspace?tabs=azure-portal&WT.mc_id=javascript-0000-yolasors[Log Analytics workspace] is the environment for Azure Monitor log data. Each workspace has its own data repository and configuration, and data sources and solutions are configured to store their data in a particular workspace. We will use the same workspace for most of the Azure resources we will be creating.

Create a Log Analytics workspace with the following command:

[source,shell]
----
az monitor log-analytics workspace create \
  --resource-group "$RESOURCE_GROUP" \
  --location "$LOCATION" \
  --tags system="$TAG" \
  --workspace-name "$LOG_ANALYTICS_WORKSPACE"
----

Let's also retrieve the Log Analytics Client ID and client secret and store them in environment variables:

[source,shell]
----
LOG_ANALYTICS_WORKSPACE_CLIENT_ID=$(az monitor log-analytics workspace show  \
  --resource-group "$RESOURCE_GROUP" \
  --workspace-name "$LOG_ANALYTICS_WORKSPACE" \
  --query customerId  \
  --output tsv | tr -d '[:space:]')

echo $LOG_ANALYTICS_WORKSPACE_CLIENT_ID

LOG_ANALYTICS_WORKSPACE_CLIENT_SECRET=$(az monitor log-analytics workspace get-shared-keys \
  --resource-group "$RESOURCE_GROUP" \
  --workspace-name "$LOG_ANALYTICS_WORKSPACE" \
  --query primarySharedKey \
  --output tsv | tr -d '[:space:]')

echo $LOG_ANALYTICS_WORKSPACE_CLIENT_SECRET
----

===== Azure Container Registry

In the next chapters we will be creating Docker containers and pushing them to the Azure Container Registry. https://azure.microsoft.com/products/container-registry/?WT.mc_id=javascript-0000-yolasors[Azure Container Registry] is a private registry for hosting container images. Using the Azure Container Registry, you can store Docker-formatted images for all types of container deployments.

First, let's created an Azure Container Registry with the following command:

[source,shell]
----
az acr create \
  --resource-group "$RESOURCE_GROUP" \
  --location "$LOCATION" \
  --tags system="$TAG" \
  --name "$REGISTRY" \
  --workspace "$LOG_ANALYTICS_WORKSPACE" \
  --sku Standard \
  --admin-enabled true
----

Update the repository to allow anonymous users to pull the images:

[source,shell]
----
az acr update \
  --resource-group "$RESOURCE_GROUP" \
  --name "$REGISTRY" \
  --anonymous-pull-enabled true
----

Get the URL of the Azure Container Registry and set it to the REGISTRY_URL variable with the following command:

[source,shell]
----
REGISTRY_URL=$(az acr show \
  --resource-group "$RESOURCE_GROUP" \
  --name "$REGISTRY" \
  --query "loginServer" \
  --output tsv)

echo $REGISTRY_URL
----

If you log into the https://portal.azure.com?WT.mc_id=javascript-0000-yolasors[Azure Portal] and search for the "java-runtimes" resource group, you should see the following created resources.

// TODO: Add screenshot

===== Creating the Container Apps environment





=== Setting Up GitHub

