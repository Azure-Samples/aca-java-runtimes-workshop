[[scaling]]
= Scaling

'''

Our microservices have several endpoints consuming memory or CPU.
Depending on the number of iterations and bites we pass as parameters to these endpoints, it can take significantly longer to respond.
We are going to explore the problem by looking at CPU and memory metrics.

== CPU

When you know CPU usage you are better prepared to answer the following questions:

* Is the amount of CPU resources maxed out?
* Have I over provisioned the amount of CPU resources?
* What does the baseline of usage looks like?
* Is there room to grow without scaling out or up?
* How much of the available CPU resources is it really using?
* What type of load is it?

== Memory

When you know memory usage you are better prepared to answer the following questions:

* Is the amount of memory used close to the maximum available memory?
* Have I over provisioned the amount of memory resources?
* What does the baseline of usage look like?
* Is there room to grow without scaling out or up?
* How much of the available memory resources is it really using?

[[scaling-listing-rest-resource]]
.REST Resource
[source,indent=0]
----
----

== Monitoring

One of the first thing you usually want to do once your application is deployed is to configure monitoring.
We'll use the https://portal.azure.com[Azure portal] to create a nice dashboard for monitoring our application metrics.

Open the Azure portal and navigate to the resource group `rg-java-runtimes` you created for your application. Select the `quarkus-app` container app, then select *Metrics* from the left menu, under the *Monitoring* group.

image::../images/aca-metrics.png[Screenshot of the Azure portal showing the metrics panel for the container app]

Using the *Metrics* panel, you can select which metrics you want to observe, and the time range for the data. Under the _Standard Metrics_ namespace, you can see the list of available built-in metrics for your application. You can also create https://learn.microsoft.com/azure/azure-monitor/essentials/metrics-custom-overview?[your own custom metrics].

image::../images/standard-metrics.png[Screenshot of the Azure portal showing the list of standard metrics]

Select "_CPU Usage_" from the list of metrics, and select the last 30 minutes hours for the time range. You can see the CPU and memory usage for your application.

image::../images/metrics-cpu.png[Screenshot of the Azure portal showing the list of standard metrics]

=== Creating charts for all services

Now let's add the CPU metrics of the Micronaut and Spring apps to the same chart.
Select *Add metric* and select "_CPU Usage_" again. Then click on the *Scope* setting, unselect `quarkus-app` and pick the `micronaut-app`. Select *Apply*, and repeat the same for the `spring-app`.

Now you should see a nice chart with the CPU usage of all three applications. Let's save this chart on the dashboard!

Select *Save to dashboard* and choose *Pin to dashboard*:

image::../images/metrics-save.png[Screenshot of the Azure portal showing the save to dashboard options]

In the _Pin to dashboard_ dialog, select *Create new* and give it a name, for example "Java Runtimes" then click *Create and pin*.

image::../images/dashboard-create.png[Screenshot of the Azure portal showing the dashboard creation dialog]

We'll also add charts to monitor the memory usage and number of replicas of our applications.

Select *Add chart* and repeat the same steps as before to create a chart with "_Memory Working Set Bytes_" metrics and another one with the "_Replica Count_" metric. Don't forget to save them to the dashboard we created earlier!

When you're finished, in the Azure portal sidebar select *Dashboards* and choose the "_Java Runtimes_" dashboard we created earlier.

image::../images/dashboard-select.png[Screenshot of Azure portal dashboard selection]

You should now see the 3 charts you just created. You can rearrange the charts by dragging them around, and resize them by dragging the bottom right corner.

image::../images/dashboard-scale.png[Screenshot of dashboard showing metrics for our applications]

== Logs

The Azure portal also provides a nice interface to view the logs of your application. This is crucial to troubleshoot issues when something goes wrong.

You have multiple options to view the different logs of your application:

- You can connect to a given container apps instance and gets the stream of console logs. This is useful to troubleshoot issues with a specific instance of your application in real time.

- You can also access the console logs in Azure portal. You get access to all logs from the https://learn.microsoft.com/azure/azure-monitor/logs/log-analytics-overview[Log Analytics] workspace we created earlier. Using SQL-like queries, you can filter the logs and get the information you need across all your applications, revisions, and instances.

- Finally, you also have access to the _system logs_, which are the logs of the container host. It's very useful to troubleshoot issues with the container host itself and find out why your container is not running.

=== Streaming logs of a container instance

The most straightforward way to access the logs of your application is to connect to a given container instance and get the stream of console logs.
You can directly access the stream of logs from the latest revision of a running instance of your application with this command:

[source,shell]
----
 az containerapp logs show \
  --name "$QUARKUS_APP" \
  --resource-group "$RESOURCE_GROUP" \
  --format text \
  --follow
----

[TIP]
====
Don't forget that by default, containers apps scale out to 0 instances when they are not used. You can use the command `curl https://${QUARKUS_HOST}/quarkus` to wake up the container app first if the connections fails.
====

Once you're connected, you can see the logs of your application in real time. The `--follow` option keeps the connection open to see the new logs in real time.

In a different terminal, you can use the `curl` command to generate some load on the application. You should see the logs of the application being updated in real time.

[source,shell]
----
curl https://${QUARKUS_HOST}/quarkus/cpu?iterations=10
----

=== Viewing the console logs in Azure portal

You can also access the console logs in Azure portal. Using https://learn.microsoft.com/azure/azure-monitor/logs/log-analytics-overview[Log Analytics], you get access to all logs from all your applications, revisions, and instances. This means you can troubleshoot issues across all your applications, tracing requests as needed, which is crucial if your application use a microservices architecture.

Open the Azure portal and navigate to the resource group `rg-java-runtimes` you created for your application. Select the `logs-java-runtimes` container app, then select *Logs* from the left menu, under the *General* group.

By default, you are presented a list of pre-defined queries. Close this panel by clicking on the *X* button on the top right corner, as we'll create our own query.

image::../images/log-analytics.png[Screenshot of the Azure portal showing the logs analytics panel]

Log analytics queries use the https://docs.microsoft.com/en-us/azure/azure-monitor/log-query/query-language[Kusto query language], which is a SQL-like language. You can use the query language to filter the logs and get the information you need.

Let's start by creating a query to get the logs of the `quarkus-app` container app. Enter this query in the editor:

[source,sql]
----
ContainerAppConsoleLogs_CL
| where RevisionName_s == "quarkus-app--<REVISION_ID>"
----

You can get the app revision name by running the following command:

[source,shell]
----
az containerapp revision list \
  --name "$QUARKUS_APP" \
  --resource-group "$RESOURCE_GROUP" \
  --query "[0].name" --output tsv
----

Select *Run* to execute the query. You should see the logs of the `quarkus-app` container app.

image::../images/log-query.png[Screenshot of the logs results in Azure portal]

For now, it's not very useful as it's the same logs we saw in the previous section. Let's add some filters to the query to search for error messages from the logs:

[source,sql]
----
ContainerAppConsoleLogs_CL
| where RevisionName_s == "quarkus-app--<REVISION_ID>"
| where Log_s !has "INFO"
| where Log_s contains "error"
----

Select *Run* to execute the query. If your application is working fine, you should not see any results.
Let's generate some errors by crashing the application with the following command:

[source,shell]
----
curl https://${QUARKUS_HOST}/quarkus/memory?bites=1000
----

Oops! We're trying to allocate more memory than the container has available, resulting in a crash because of our (crude) memory allocation algorithm.

If you run the query again, you should see the error message in the logs:

image::../images/log-query-error.png[Screenshot of the logs results in Azure portal]

[TIP]
====
Of course, you can go much further with the query language. You can have a look at the https://learn.microsoft.com/en-us/azure/data-explorer/kql-quick-reference[quick reference] to play a bit with the queries.
====

We can make it easier to read by making the latest logs appear at the top of the results, and only show the time and message of the last 10 logs:

[source,sql]
----
ContainerAppConsoleLogs_CL
| where RevisionName_s == "quarkus-app--<REVISION_ID>"
| where Log_s !has "INFO"
| where Log_s contains "error"
| project TimeGenerated, Log_s
| sort by TimeGenerated desc
| take 10
----

And here we can quickly see our `OutOfMemoryError` error message.

image::../images/log-query-error-2.png[Screenshot of the logs results in Azure portal]

We can save the query for later use by clicking on the *Save* button. You can then give it a name and a description, and a category to quickly find it later.

=== Viewing the system logs

//  Navigate to the `quarkus-app` container app, then select *Logs* from the left menu, under the *Monitoring* group.
// Open console/system logs from the CLI for each service

== Load Testing

Now it's time to add some load to the application. This will allow us to see how the auto-scaling features works in Azure Container Apps.

To add some load to an application, you can do it locally using https://jmeter.apache.org[JMeter], but you can also do it remotely on Azure using https://azure.microsoft.com/services/load-testing[Azure Load Testing] and JMeter.

Azure Load Testing is a fully managed load-testing service built for Azure that makes it easy to generate high-scale load and identify app performance bottlenecks.
It is available on the https://azuremarketplace.microsoft.com[Azure Marketplace].

=== Setting up Azure Load Testing

To use Azure Load Testing, go to the https://portal.azure.com[Azure Portal], select *Create a resource* in the sidebar and search for "_Azure Load Testing_".

image::../images/portal-create-resource-load-testing.png[Screenshot of searching for Azure Load Testing in Azure Portal]

1. Select *Create*:
+
image::../images/load-testing-create.png[Azure Load Testing creation screen]

2. In the **Resource group** field, select the `rg-java-runtimes` that we created previously.

3. Set the name `lt-java-runtimes` for the load testing instance.

4. Set the location to match our previously created resources (East US).

5. Select **Review + Create**, then **Create**.

Creating a load testing resource can take a few moment.
Once created, you should see the Azure Load Testing available in your resource group: 

image::../images/load-testing-group.png[Screenshot of Azure Load Testing in Resource group]

Select `lt-java-runtimes`, and then click on *Tests* and then *Create*.

image::../images/load-testing-create-test.png[Screenshot of test creation]

1. You can either create a quick load test using a wizard, or create a load test using a JMeter script. Choose this second option.

2. Before uploading a JMeter script, create a load test by entering a name (eg. "_Make them fight_"), a description and select **Next**: 
+
image::../images/load-testing-jmeter.png[Screenshot of test setup]

3. Now that you are on the "Test plan" tab, you can upload the JMeter file (located under `scripts/jmeter/src/test/jmeter/load.jmx`) as well as the `user.properties` file. 
+
The JMeter file sets up a load campaign targetting the "cpu" endpoint.
+
Before uploading the `user.properties` file, make sure you change the properties so you target the `FightResource` endpoint URL:
+
[source,properties]
----
# Change these numbers depending on the load you want to add to the application
LOOPS=20
THREADS=2
RAMP=1

# Put your quarkus host here
QUARKUS_HOST=quarkus-app.mangodesert-f75fa955.eastus.azurecontainerapps.io
QUARKUS_PROTOCOL=https
QUARKUS_PORT=443

# Put your spring host here
SPRING_HOST=springboot-app.mangodesert-f75fa955.eastus.azurecontainerapps.io
SPRING_PROTOCOL=https
SPRING_PORT=443

# Put your micronaut host here
MICRONAUT_PROTOCOL=https
MICRONAUT_HOST=micronaut-app.mangodesert-f75fa955.eastus.azurecontainerapps.io
MICRONAUT_PORT=443
----

4. Select *Upload*, and choose "_User properties_" in the *File relevance* field of the `user.properties` file.
+
image::../images/load-testing-upload.png[Screenshot of test plan setup]

5. Select *Review + Create*, then *Create*.

=== Running the tests

After the test creation, it will start automatically after a short time.
When the test run finishes, you will get some metrics:

image::../images/load-testing-metrics.png[Screenshot of test run]

In the Azure portal sidebar, select *Dashboards* and go back to the "_Java Runtimes_" dashboard we created earlier.

If you take a look at the charts, you can see CPU and memory usage increase, and also that the number of replicas has increased from 1 replica to 10.
Azure Container Apps has scaled automatically the application depending on the load.

// TODO: update with 3 services
image::../images/dashboard-scale.png[Screenshot of dashboard showing load testing results]

== Scaling

// Set up CPU/Memory scaling
// Run load tests again with updated parameters
